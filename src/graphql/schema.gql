scalar AWSEmail
scalar AWSPhone
scalar AWSTimestamp
scalar AWSURL

type Query{
    findUser(address:ID!): userAuthData!
    @aws_api_key
        
    authUser: authUserOutput!    
    @aws_lambda  

    getUserProfile(input: getUserProfileInput!):user!
    @aws_api_key @aws_lambda

    getUsersNfts(input: getUsersNftsInput!): getUsersNftsOutput!
    @aws_api_key @aws_lambda
    
    indexNftAddress(input: indexNftAddressInput!): String!
    getNftInfo(input: getNftInfoInput!): Nft!
    getNftOwners(input: getNftOwnersInput!): getNftOwnersOutput!

    usernameAvailable(username: String!): Boolean!
    @aws_lambda

    getListedNfts(input: getListedNftsInput!): getListedNftsOutput!
    @aws_lambda @aws_api_key

}


type Mutation{
    followUser(input: followUserInput!): String!
    @aws_lambda
    listNft(input:listNftInput! ): NftListing!
    @aws_lambda
    signup(address: ID!): userAuthData!
    @aws_api_key
    authenticate(address: ID!, signature: String!): String!
    @aws_api_key
    refreshAccessToken: String!        
    @aws_lambda
    updateProfile(input: updateProfileInput!): user!
    @aws_lambda
}

input updateProfileInput {
    username: String
    displayName: String
    bio: String
    email: String
    coverImage: String
    profileImage: String
}


type getNftOwnersOutput{
    data: [nftOwner]!
    count: Int!
}

type nftOwner{
user: user!
amount: Int!
}

input getListedNftsInput{
    category: [CATEGORY!]
    listingType: LISTING_TYPE
    sortingOrder: SORTING_ORDER!
    auctionEndingSoon: Boolean
    sortBy: SORT_BY!
    pageSize:Int!
    before: [String!]
    after: [String!]

}



input getNftOwnersInput {
    nftAddress: String!
    tokenId: String!
    pageSize:Int!
    pageNumber:Int!
}


input getNftInfoInput {
    nftAddress: String!
    tokenId: String!
}

input indexNftAddressInput{
    nftAddress:String!
}

input followUserInput {
    publicAddress:ID!
}

input getUsersNftsInput {
    pageSize:Int!
    pageNumber:Int!
    userPublicAddress:ID
    refId: ID
    username: ID
}


input getUserProfileInput{
    publicAddress:ID
    refId: ID
    username: ID
}

type getUsersNftsOutput @aws_api_key @aws_lambda {
    data: [Nft]!
    count: Int!
}

type userAuthData @aws_lambda @aws_api_key {
   publicAddress: ID!
   joiningDate: AWSTimestamp
   nonce: String
   tokenExpiryDate: AWSTimestamp
}

type user @aws_lambda @aws_api_key {
    publicAddress: ID
    refId: ID
    username: String
    displayName: String
    bio: String
    email: String
    coverImage: String
    profileImage: String
}

type authUserOutput @aws_lambda @aws_api_key{
    userData: user!
    userAuthData: userAuthData!
}


type Nft {
    tokenId: String
    nftAddress: ID
    tokenUri: String
    contractType: CONTRACT_TYPE
    name: String
    amount: String
    symbol: String
    blockNumber: Int
    blockNumberMinted: Int
    metadata: String
    syncedAt: String
}


enum CONTRACT_TYPE {
    ERC1155
    ERC721
}


type getListedNftsOutput {

nfts: [NftListing!]!
before: [String]
after: [String]

} 

interface NftListing @aws_lambda @aws_api_key {
listedBy_publicAddress: ID!
listedBy_username: ID!
listedBy_refId:ID!
category: [CATEGORY!]!
tags: [String!]
listingType: LISTING_TYPE!
blockChainUpdateStatus: BLOCKCHAIN_UPDATE_STATUS!
amount: Int!
contractType: CONTRACT_TYPE!
tokenUri: String
contractAddress:String!
tokenId:String!

}

type nftAuctionListing implements NftListing @aws_lambda @aws_api_key {
listedBy_publicAddress: ID!
listedBy_username: ID!
listedBy_refId:ID!
category: [CATEGORY!]!
tags: [String!]
listingType: LISTING_TYPE!  
auctionEndingDate: AWSTimestamp!
highestBid: Int
basePrice:Int
blockChainUpdateStatus: BLOCKCHAIN_UPDATE_STATUS!
amount: Int!
contractType: CONTRACT_TYPE!
tokenUri: String
contractAddress:String!
tokenId:String!
}

type nftSellListing implements NftListing @aws_lambda @aws_api_key {
listedBy_publicAddress: ID!
listedBy_username: ID!
listedBy_refId:ID!
category: [CATEGORY!]!
tags: [String!]
listingType: LISTING_TYPE!  
sellPrice: Int
blockChainUpdateStatus: BLOCKCHAIN_UPDATE_STATUS!
amount: Int!
contractType: CONTRACT_TYPE!
tokenUri: String
contractAddress:String!
tokenId:String!

}



input listNftInput{
    contractAddress:String!
    tokenId: String!
    category: [CATEGORY!]!
    tags: [String!]
    listingType: LISTING_TYPE!
    sellPrice: Int
    basePrice: Int
    auctionEndingDate: AWSTimestamp
    amount: Int!
    contractType: CONTRACT_TYPE!

}


# interface NftListing {
#     owner: User
#     timeStamp:AWSTimestamp
#     contractAddress:String
#     tokenId: String
#     imageUrl: String
#     metaDataUrl: String
#     EtherscanUrl: String
#     description:String
#     category: [CATEGORY!]!
#     tags: [String!]
#     listingType: LISTING_TYPE!
#     status: NFT_STATUS
   
# }


# type nftAuctionListing implements NftListing{
#     owner: User
#     contractAddress:String
#     timeStamp:AWSTimestamp
#     tokenId: String
#     imageUrl: String
#     metaDataUrl: String
#     EtherscanUrl: String
#     description:String
#     category: [CATEGORY!]!
#     tags: [String!]
#     listingType: LISTING_TYPE! 
#     auctionEndingDate: AWSTimestamp!
#     highestBid: Int
#     status: NFT_STATUS
#     basePrice:Int

# }


# type nftSellListing implements NftListing{
#     owner: User
#     contractAddress:String
#     timeStamp:AWSTimestamp
#     tokenId: String
#     imageUrl: String
#     metaDataUrl: String
#     EtherscanUrl: String
#     description:String
#     category: [CATEGORY!]!
#     tags: [String!]
#     listingType: LISTING_TYPE! 
#     status: NFT_STATUS
#     sellPrice: Int
# }




enum LISTING_TYPE{
    AUCTION
    SELL
}



enum CATEGORY{
    GAMING
    ART
}

enum BLOCKCHAIN_UPDATE_STATUS{
    CONFIRMED
    PENDING
}

enum SORT_BY{
    date
    price
}

enum SORTING_ORDER{
    ASC
    DESC
}


# enum NFT_STATUS{
#     LISTED
#     SOLD
# }